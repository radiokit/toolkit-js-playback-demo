{"version":3,"sources":["webpack:///webpack/bootstrap 7833e553ef752b7a9afc","webpack:///./lib/index.ts","webpack:///./lib/channel/Player.ts","webpack:///./lib/Base.ts","webpack:///./lib/clock/SyncClock.ts","webpack:///./lib/channel/PlaylistFetcher.ts","webpack:///./lib/channel/PlaylistResolver.ts","webpack:///./lib/channel/Playlist.ts","webpack:///./lib/channel/Track.ts","webpack:///./lib/channel/TrackInfo.ts","webpack:///./lib/audio/AudioManager.ts","webpack:///./lib/audio/Factory.ts","webpack:///./lib/audio/HTMLPlayer.ts","webpack:///./lib/audio/StreamManager.ts","webpack:///./~/phoenix/priv/static/phoenix.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACZA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qIAAoI,qDAAqD;AACzL;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACnOA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,4DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpEA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1DA;AACA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA,kCAAiC,cAAc;AAC/C,2BAA0B;AAC1B,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC5EA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD,oDAAmD;AACnD;AACA,oDAAmD;AACnD,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACjEA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA,oDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpCA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC5HA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,gBAAgB;AACvE;AACA;AACA;AACA,sDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AChCA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpGA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACXA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClPA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT,8CAA6C,+DAA+D,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtJA;AACA;;AAEA,qGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O,iCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;AACA;AACA,EAAC;;AAED,mCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM,kDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,SAAS,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA,mCAAkC,mBAAmB;AACrD;AACA;AACA;AACA,SAAQ;AACR;AACA,2BAA0B,SAAS;AACnC,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,yBAAwB,6CAA6C;AACrE,SAAQ;AACR;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,2CAA0C,aAAa;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,qCAAqC;AAC/D;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,oCAAmC;AACnC,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,4CAA2C,qCAAqC;AAChF;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,2BAA0B,mCAAmC;AAC7D;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,mCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,gBAAgB,KAAK,IAAI,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wEAAuE;;AAEvE;;AAEA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,mFAAkF,WAAW;AAC7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAkE,mBAAmB;;AAErF,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAAyC,6BAA6B;AACtE;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,gFAA+E;;AAE/E;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,kBAAiB,kDAAkD,uBAAuB;AAC1F;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC,mCAAkC;AAClC,qCAAoC;AACpC,mCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oDAAmD,oBAAoB;AACvE;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,wCAAuC,4BAA4B;AACnE,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA,QAAO;AACP;AACA,gDAA+C;AAC/C;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED,gBAAe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;AACL,kCAAiC,+BAA+B;AAChE,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA,EAAC;;AAED,EAAC,gDAAyE","file":"radiokit-toolkit-playback.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7833e553ef752b7a9afc","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Player_1 = require(\"./channel/Player\");\nexports.Channel = {\n    Player: Player_1.Player,\n};\nif (typeof (window) !== \"undefined\") {\n    window['RadioKitToolkitPlayback'] = {\n        Channel: {\n            Player: Player_1.Player,\n        }\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.ts\n// module id = 0\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base_1 = require(\"../Base\");\nvar SyncClock_1 = require(\"../clock/SyncClock\");\nvar PlaylistFetcher_1 = require(\"../channel/PlaylistFetcher\");\nvar AudioManager_1 = require(\"../audio/AudioManager\");\nvar StreamManager_1 = require(\"../audio/StreamManager\");\nvar Player = (function (_super) {\n    __extends(Player, _super);\n    function Player(channelId, accessToken, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.__fetchTimeoutId = 0;\n        _this.__playbackStartedEmitted = false;\n        _this.__playlist = null;\n        _this.__clock = null;\n        _this.__fetching = false;\n        _this.__playlistFetcher = null;\n        _this.__volume = 1.0;\n        _this.__options = { from: 20, to: 600 };\n        _this.__options = __assign({}, _this.__options, options);\n        _this.__started = false;\n        _this.__channelId = channelId;\n        _this.__accessToken = accessToken;\n        return _this;\n    }\n    Player.prototype.start = function () {\n        if (!this.__started) {\n            this.__startFetching();\n            this.__started = true;\n            this.__playbackStartedEmitted = false;\n            if (this.__supportsAudioManager()) {\n                this.debug(\"Using AudioManager\");\n                this.__audioManager = new AudioManager_1.AudioManager();\n                this.__audioManager.setVolume(this.__volume);\n                this.__audioManager.on('playback-started', this.__onAudioManagerPlaybackStarted.bind(this));\n                this.__audioManager.on('position', this.__onAudioManagerPosition.bind(this));\n            }\n            else {\n                this.debug(\"Using StreamManager\");\n                this.__streamManager = new StreamManager_1.StreamManager(this.__channelId);\n                this.__streamManager.setVolume(this.__volume);\n                this.__streamManager.on('channel-metadata-update', this.__onStreamManagerChannelMetadataUpdate.bind(this));\n                this.__streamManager.on('playback-started', this.__onStreamManagerPlaybackStarted.bind(this));\n                this.__streamManager.start();\n            }\n        }\n        return this;\n    };\n    Player.prototype.stop = function () {\n        if (this.__started) {\n            this.__started = false;\n            if (this.__audioManager) {\n                this.__audioManager.offAll();\n                this.__audioManager.cleanup();\n                delete this.__audioManager;\n                this.__audioManager = undefined;\n            }\n            else if (this.__streamManager) {\n                this.__streamManager.offAll();\n                this.__streamManager.stop();\n                delete this.__streamManager;\n                this.__streamManager = undefined;\n            }\n            return this;\n        }\n    };\n    Player.prototype.setVolume = function (volume) {\n        if (volume < 0.0 || volume > 1.0) {\n            throw new Error('Volume out of range');\n        }\n        this.debug(\"Volume set to \" + volume);\n        this.__volume = volume;\n        if (this.__audioManager) {\n            this.__audioManager.setVolume(volume);\n        }\n        return this;\n    };\n    Player.prototype.getVolume = function () {\n        return this.__volume;\n    };\n    Player.prototype.isStarted = function () {\n        return this.__started;\n    };\n    Player.prototype.fetchPlaylist = function () {\n        this.__startFetching();\n        return this;\n    };\n    Player.prototype.stopFetching = function () {\n        if (this.__fetching) {\n            this.__fetching = false;\n            if (this.__fetchTimeoutId !== 0) {\n                clearTimeout(this.__fetchTimeoutId);\n                this.__fetchTimeoutId = 0;\n            }\n        }\n    };\n    Player.prototype._loggerTag = function () {\n        return this['constructor']['name'] + \" \" + this.__channelId;\n    };\n    Player.prototype.__supportsAudioManager = function () {\n        return (!this.__isAndroid() &&\n            !this.__isIPhone() &&\n            !this.__isSafari());\n    };\n    Player.prototype.__isAndroid = function () {\n        return navigator.userAgent.indexOf('Android') !== -1;\n    };\n    Player.prototype.__isIPhone = function () {\n        return navigator.userAgent.indexOf('iPhone') !== -1;\n    };\n    Player.prototype.__isSafari = function () {\n        return navigator.userAgent.indexOf('Chrome') === -1 && navigator.userAgent.indexOf('Safari') !== -1;\n    };\n    Player.prototype.__startFetching = function () {\n        if (!this.__fetching) {\n            this.__fetching = true;\n            this.__fetchOnceAndRepeat();\n        }\n    };\n    Player.prototype.__fetchOnce = function () {\n        var _this = this;\n        if (this.__clock === null) {\n            this.debug(\"Fetch: Synchronizing clock...\");\n            var promise = new Promise(function (resolve, reject) {\n                SyncClock_1.SyncClock.makeAsync()\n                    .then(function (clock) {\n                    _this.debug(\"Fetch: Synchronized clock\");\n                    _this.__clock = clock;\n                    _this.__playlistFetcher = new PlaylistFetcher_1.PlaylistFetcher(_this.__accessToken, _this.__channelId, clock, { from: _this.__options.from, to: _this.__options.to });\n                    return _this.__fetchPlaylist(resolve, reject);\n                })\n                    .catch(function (error) {\n                    _this.warn(\"Fetch error: Unable to sync clock (\" + error.message + \")\");\n                    _this._trigger('error-network');\n                    reject(new Error(\"Unable to sync clock (\" + error.message + \")\"));\n                });\n            });\n            return promise;\n        }\n        else {\n            var promise = new Promise(function (resolve, reject) {\n                _this.__fetchPlaylist(resolve, reject);\n            });\n            return promise;\n        }\n    };\n    Player.prototype.__fetchPlaylist = function (resolve, reject) {\n        var _this = this;\n        this.debug(\"Fetch: Fetching playlist...\");\n        this.__playlistFetcher.fetchAsync()\n            .then(function (playlist) {\n            _this.debug(\"Fetch: Done\");\n            resolve(playlist);\n        })\n            .catch(function (error) {\n            _this.warn(\"Fetch error: Unable to fetch playlist (\" + error.message + \")\");\n            _this._trigger('error-network');\n            reject(new Error(\"Unable to fetch playlist (\" + error.message + \")\"));\n        });\n    };\n    Player.prototype.__fetchOnceAndRepeat = function () {\n        var _this = this;\n        this.__fetchOnce()\n            .then(function (playlist) {\n            _this.__playlist = playlist;\n            _this.__onPlayListFetched(playlist);\n            _this.__started && _this.__audioManager && _this.__audioManager.update(_this.__playlist, _this.__clock);\n            _this.__scheduleNextFetch();\n        })\n            .catch(function (error) {\n            _this.__scheduleNextFetch();\n        });\n    };\n    Player.prototype.__scheduleNextFetch = function () {\n        var _this = this;\n        if (this.__fetching) {\n            var timeout = 2000 + Math.round(Math.random() * 250);\n            this.debug(\"Fetch: Scheduling next fetch in \" + timeout + \" ms\");\n            this.__fetchTimeoutId = setTimeout(function () {\n                _this.__fetchTimeoutId = 0;\n                _this.__fetchOnceAndRepeat();\n            }, timeout);\n        }\n    };\n    Player.prototype.__onPlayListFetched = function (playlist) {\n        this._trigger('playlist-fetched', playlist);\n    };\n    Player.prototype.__onAudioManagerPosition = function (track, position, duration) {\n        this._trigger('track-position', track, position, duration);\n    };\n    Player.prototype.__onAudioManagerPlaybackStarted = function (track) {\n        if (!this.__playbackStartedEmitted) {\n            this._trigger('playback-started');\n            this.__playbackStartedEmitted = true;\n        }\n        this._trigger('track-playback-started', track);\n    };\n    Player.prototype.__onStreamManagerPlaybackStarted = function () {\n        if (!this.__playbackStartedEmitted) {\n            this._trigger('playback-started');\n            this.__playbackStartedEmitted = true;\n        }\n    };\n    Player.prototype.__onStreamManagerChannelMetadataUpdate = function (payload) {\n        this._trigger('channel-metadata-update', payload);\n    };\n    return Player;\n}(Base_1.Base));\nexports.Player = Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/Player.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base = (function () {\n    function Base() {\n        this.__events = {};\n    }\n    Base.prototype.on = function (eventName, callback) {\n        if (this.__events.hasOwnProperty(eventName)) {\n            if (this.__events[eventName].indexOf(callback) === -1) {\n                this.__events[eventName].push(callback);\n            }\n            else {\n                throw new Error(\"Trying to addd twice the same callback for event \\\"\" + eventName + \"\\\"\");\n            }\n        }\n        else {\n            this.__events[eventName] = [callback];\n        }\n        return this;\n    };\n    Base.prototype.off = function (eventName, callback) {\n        if (this.__events.hasOwnProperty(eventName)) {\n            var index = this.__events[eventName].indexOf(callback);\n            if (index !== -1) {\n                this.__events[eventName].splice(index, 1);\n            }\n            else {\n                throw new Error(\"Trying to remove non-existent callback for event \\\"\" + eventName + \"\\\"\");\n            }\n        }\n        return this;\n    };\n    Base.prototype.offAll = function (eventName) {\n        if (eventName) {\n            if (this.__events.hasOwnProperty(eventName)) {\n                delete this.__events[eventName];\n            }\n        }\n        else {\n            this.__events = {};\n        }\n        return this;\n    };\n    Base.prototype._trigger = function (eventName) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this.debug(\"Event: \" + eventName + \" (\" + JSON.stringify(args) + \")\");\n        if (this.__events.hasOwnProperty(eventName)) {\n            for (var _a = 0, _b = this.__events[eventName]; _a < _b.length; _a++) {\n                var callback = _b[_a];\n                callback.apply(this, args);\n            }\n        }\n        return this;\n    };\n    Base.prototype.warn = function (message) {\n        console.warn(\"[\" + new Date().toISOString() + \" RadioKit.Toolkit.Playback \" + this._loggerTag() + \"] \" + message);\n    };\n    Base.prototype.info = function (message) {\n        console.info(\"[\" + new Date().toISOString() + \" RadioKit.Toolkit.Playback \" + this._loggerTag() + \"] \" + message);\n    };\n    Base.prototype.debug = function (message) {\n        console.debug(\"[\" + new Date().toISOString() + \" RadioKit.Toolkit.Playback \" + this._loggerTag() + \"] \" + message);\n    };\n    return Base;\n}());\nexports.Base = Base;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Base.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base_1 = require(\"../Base\");\nvar SyncClock = (function (_super) {\n    __extends(SyncClock, _super);\n    function SyncClock(serverDate) {\n        var _this = _super.call(this) || this;\n        _this.__offset = serverDate - Date.now();\n        _this.debug(\"Synchronized clock: offset = \" + _this.__offset + \" ms\");\n        return _this;\n    }\n    SyncClock.makeAsync = function () {\n        var promise = new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.open('OPTIONS', 'https://time.radiokitapp.org/api/time/v1.0/now', true);\n            xhr.setRequestHeader('Cache-Control', 'no-cache, must-revalidate');\n            xhr.timeout = 5000;\n            xhr.onerror = function (e) {\n                reject(new Error(\"Unable to synchronize clock: Network error (\" + xhr.status + \")\"));\n            };\n            xhr.onabort = function (e) {\n                reject(new Error(\"Unable to synchronize clock: Aborted\"));\n            };\n            xhr.ontimeout = function (e) {\n                reject(new Error(\"Unable to synchronize clock: Timeout\"));\n            };\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        resolve(new SyncClock(Date.parse(JSON.parse(xhr.responseText).utc_time)));\n                    }\n                    else {\n                        reject(new Error(\"Unable to synchronize clock: Unexpected response (status = \" + xhr.status + \")\"));\n                    }\n                }\n            };\n            xhr.send();\n        });\n        return promise;\n    };\n    SyncClock.prototype.nowAsTimestamp = function () {\n        return Date.now() + this.__offset;\n    };\n    SyncClock.prototype._loggerTag = function () {\n        return this['constructor']['name'];\n    };\n    return SyncClock;\n}(Base_1.Base));\nexports.SyncClock = SyncClock;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/clock/SyncClock.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PlaylistResolver_1 = require(\"./PlaylistResolver\");\nvar PlaylistFetcher = (function () {\n    function PlaylistFetcher(accessToken, channelId, clock, options) {\n        if (options === void 0) { options = {}; }\n        this.__options = { from: 20, to: 600 };\n        this.__options = __assign({}, this.__options, options);\n        this.__clock = clock;\n        this.__channelId = channelId;\n        this.__accessToken = accessToken;\n    }\n    PlaylistFetcher.prototype.fetchAsync = function () {\n        var _this = this;\n        var promise = new Promise(function (resolve, reject) {\n            var now = _this.__clock.nowAsTimestamp();\n            var xhr = new XMLHttpRequest();\n            var url = 'https://plumber.radiokitapp.org/api/rest/v1.0/media/input/file/radiokit/vault' +\n                '?a[]=id' +\n                '&a[]=name' +\n                '&a[]=file' +\n                '&a[]=cue_in_at' +\n                '&a[]=cue_out_at' +\n                '&a[]=cue_offset' +\n                '&a[]=fade_in_at' +\n                '&a[]=fade_out_at' +\n                '&s[]=cue%20' + encodeURIComponent(new Date(now).toISOString()) +\n                encodeURIComponent(\" \" + _this.__options.from + \" \" + _this.__options.to) +\n                '&c[references][]=deq%20broadcast_channel_id%20' + encodeURIComponent(_this.__channelId) +\n                '&o[]=cue_in_at%20asc';\n            xhr.open('GET', url, true);\n            xhr.setRequestHeader('Cache-Control', 'no-cache, must-revalidate');\n            xhr.setRequestHeader('Authorization', \"Bearer \" + _this.__accessToken);\n            xhr.setRequestHeader('Accept', 'application/json');\n            xhr.timeout = 15000;\n            xhr.onerror = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Network error (\" + xhr.status + \")\"));\n            };\n            xhr.onabort = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Aborted\"));\n            };\n            xhr.ontimeout = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Timeout\"));\n            };\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        var responseAsJson = JSON.parse(xhr.responseText);\n                        var resolver = new PlaylistResolver_1.PlaylistResolver(_this.__accessToken, responseAsJson['data']);\n                        resolver.resolveAsync()\n                            .then(function (playlist) {\n                            resolve(playlist);\n                        })\n                            .catch(function (error) {\n                            reject(new Error(\"Unable to resolve playlist (\" + error.message + \")\"));\n                        });\n                    }\n                    else {\n                        reject(new Error(\"Unable to fetch playlist: Unexpected response (status = \" + xhr.status + \")\"));\n                    }\n                }\n            };\n            xhr.send();\n        });\n        return promise;\n    };\n    return PlaylistFetcher;\n}());\nexports.PlaylistFetcher = PlaylistFetcher;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/PlaylistFetcher.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Playlist_1 = require(\"./Playlist\");\nvar PlaylistResolver = (function () {\n    function PlaylistResolver(accessToken, playlistRaw) {\n        this.__playlistRaw = playlistRaw;\n        this.__accessToken = accessToken;\n    }\n    PlaylistResolver.prototype.resolveAsync = function () {\n        var _this = this;\n        var promise = new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            var fileIds = [];\n            for (var _i = 0, _a = _this.__playlistRaw; _i < _a.length; _i++) {\n                var file = _a[_i];\n                fileIds.push(encodeURIComponent(file[\"file\"]));\n            }\n            var url = 'https://vault.radiokitapp.org/api/rest/v1.0/data/record/file' +\n                '?a[]=id' +\n                '&a[]=public_url' +\n                '&c[id][]=in%20' + fileIds.join(\"%20\");\n            xhr.open('GET', url, true);\n            xhr.setRequestHeader('Cache-Control', 'no-cache, must-revalidate');\n            xhr.setRequestHeader('Authorization', \"Bearer \" + _this.__accessToken);\n            xhr.setRequestHeader('Accept', 'application/json');\n            xhr.timeout = 15000;\n            var audio = new Audio();\n            var knownFormats = [];\n            if (audio.canPlayType('application/ogg; codecs=opus')) {\n                knownFormats.push('application/ogg; codecs=opus');\n            }\n            if (audio.canPlayType('application/ogg; codecs=vorbis')) {\n                knownFormats.push('application/ogg; codecs=vorbis');\n            }\n            if (audio.canPlayType('audio/mpeg')) {\n                knownFormats.push('audio/mpeg');\n            }\n            xhr.setRequestHeader('X-RadioKit-KnownFormats', knownFormats.join(', '));\n            xhr.onerror = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Network error (\" + xhr.status + \")\"));\n            };\n            xhr.onabort = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Aborted\"));\n            };\n            xhr.ontimeout = function (e) {\n                reject(new Error(\"Unable to fetch playlist: Timeout\"));\n            };\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        var responseAsJson = JSON.parse(xhr.responseText);\n                        var responseData = responseAsJson['data'];\n                        resolve(Playlist_1.Playlist.makeFromJson(_this.__accessToken, _this.__playlistRaw, responseData));\n                    }\n                    else {\n                        reject(new Error(\"Unable to fetch files: Unexpected response (status = \" + xhr.status + \")\"));\n                    }\n                }\n            };\n            xhr.send();\n        });\n        return promise;\n    };\n    return PlaylistResolver;\n}());\nexports.PlaylistResolver = PlaylistResolver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/PlaylistResolver.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Track_1 = require(\"./Track\");\nvar Playlist = (function () {\n    function Playlist(tracks) {\n        this.__tracks = tracks;\n    }\n    Playlist.makeFromJson = function (accessToken, playlistRaw, filesRaw) {\n        var tracks = {};\n        for (var _i = 0, playlistRaw_1 = playlistRaw; _i < playlistRaw_1.length; _i++) {\n            var playlistRecord = playlistRaw_1[_i];\n            var id = playlistRecord['id'];\n            var fileId = playlistRecord['file'];\n            var fileUrl = void 0;\n            for (var _a = 0, filesRaw_1 = filesRaw; _a < filesRaw_1.length; _a++) {\n                var fileRecord = filesRaw_1[_a];\n                if (fileRecord['id'] === playlistRecord['file']) {\n                    fileUrl = fileRecord['public_url'];\n                    break;\n                }\n            }\n            var cueInAt = new Date(playlistRecord['cue_in_at']);\n            var cueOutAt = new Date(playlistRecord['cue_out_at']);\n            var cueOffset = playlistRecord['cue_offset'];\n            var fadeInAt = playlistRecord['fade_in_at'] !== null ? new Date(playlistRecord['fade_in_at']) : null;\n            var fadeOutAt = playlistRecord['fade_out_at'] !== null ? new Date(playlistRecord['fade_out_at']) : null;\n            var track = new Track_1.Track(accessToken, id, fileId, fileUrl, cueInAt, cueOutAt, cueOffset, fadeInAt, fadeOutAt);\n            tracks[id] = track;\n        }\n        return new Playlist(tracks);\n    };\n    Playlist.prototype.getTracks = function () {\n        return this.__tracks;\n    };\n    return Playlist;\n}());\nexports.Playlist = Playlist;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/Playlist.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base_1 = require(\"../Base\");\nvar TrackInfo_1 = require(\"./TrackInfo\");\nvar Track = (function (_super) {\n    __extends(Track, _super);\n    function Track(accessToken, id, fileId, fileUrl, cueInAt, cueOutAt, cueOffset, fadeInAt, fadeOutAt) {\n        var _this = _super.call(this) || this;\n        _this.__accessToken = accessToken;\n        _this.__id = id;\n        _this.__fileId = fileId;\n        _this.__fileUrl = fileUrl;\n        _this.__cueInAt = cueInAt;\n        _this.__cueOutAt = cueOutAt;\n        _this.__cueOffset = cueOffset;\n        _this.__fadeInAt = fadeInAt;\n        _this.__fadeOutAt = fadeOutAt;\n        return _this;\n    }\n    Track.prototype.getId = function () {\n        return this.__id;\n    };\n    Track.prototype.getFileId = function () {\n        return this.__fileId;\n    };\n    Track.prototype.getFileUrl = function () {\n        return this.__fileUrl;\n    };\n    Track.prototype.getCueInAt = function () {\n        return this.__cueInAt;\n    };\n    Track.prototype.getCueOutAt = function () {\n        return this.__cueOutAt;\n    };\n    Track.prototype.getFadeInAt = function () {\n        return this.__fadeInAt;\n    };\n    Track.prototype.getFadeOutAt = function () {\n        return this.__fadeOutAt;\n    };\n    Track.prototype.getCueOffset = function () {\n        return this.__cueOffset;\n    };\n    Track.prototype.getInfoAsync = function () {\n        var _this = this;\n        var promise = new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            var url = 'https://vault.radiokitapp.org/api/rest/v1.0/data/record/file' +\n                '?a[]=id' +\n                '&a[]=name' +\n                '&a[]=stage' +\n                '&a[]=references' +\n                '&a[]=extra' +\n                '&a[]=public_url' +\n                '&a[]=metadata_schemas.id' +\n                '&a[]=metadata_schemas.name' +\n                '&a[]=metadata_schemas.key' +\n                '&a[]=metadata_schemas.kind' +\n                '&a[]=metadata_items.id' +\n                '&a[]=metadata_items.metadata_schema_id' +\n                '&a[]=metadata_items.metadata_schema_id' +\n                '&a[]=metadata_items.value_string' +\n                '&a[]=metadata_items.value_db' +\n                '&a[]=metadata_items.value_text' +\n                '&a[]=metadata_items.value_float' +\n                '&a[]=metadata_items.value_integer' +\n                '&a[]=metadata_items.value_duration' +\n                '&a[]=metadata_items.value_date' +\n                '&a[]=metadata_items.value_datetime' +\n                '&a[]=metadata_items.value_time' +\n                '&a[]=metadata_items.value_file' +\n                '&a[]=metadata_items.value_image' +\n                '&a[]=metadata_items.value_url' +\n                '&j[]=metadata_schemas' +\n                '&j[]=metadata_items' +\n                '&c[id][]=eq%20' + encodeURIComponent(_this.__fileId);\n            xhr.open('GET', url, true);\n            xhr.setRequestHeader('Authorization', \"Bearer \" + _this.__accessToken);\n            xhr.setRequestHeader('Accept', 'application/json');\n            xhr.timeout = 15000;\n            xhr.onerror = function (e) {\n                reject(new Error(\"Unable to fetch track info: Network error (\" + xhr.status + \")\"));\n            };\n            xhr.onabort = function (e) {\n                reject(new Error(\"Unable to fetch track info: Aborted\"));\n            };\n            xhr.ontimeout = function (e) {\n                reject(new Error(\"Unable to fetch track info: Timeout\"));\n            };\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        var responseAsJson = JSON.parse(xhr.responseText);\n                        if (responseAsJson[\"data\"].length === 1) {\n                            resolve(TrackInfo_1.TrackInfo.makeFromJson(responseAsJson[\"data\"][0]));\n                        }\n                        else {\n                            reject(new Error(\"Unable to fetch track info: Record not found\"));\n                        }\n                    }\n                    else {\n                        reject(new Error(\"Unable to fetch track info: Unexpected response (status = \" + xhr.status + \")\"));\n                    }\n                }\n            };\n            xhr.send();\n        });\n        return promise;\n    };\n    Track.prototype._loggerTag = function () {\n        return this['constructor']['name'] + \" \" + this.__id;\n    };\n    return Track;\n}(Base_1.Base));\nexports.Track = Track;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/Track.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TrackInfo = (function () {\n    function TrackInfo(name, metadata) {\n        this.__name = name;\n        this.__metadata = metadata;\n    }\n    TrackInfo.makeFromJson = function (data) {\n        var name = data['name'];\n        var metadata = {};\n        var metadataSchemas = {};\n        for (var _i = 0, _a = data['metadata_schemas']; _i < _a.length; _i++) {\n            var metadataSchema = _a[_i];\n            metadataSchemas[metadataSchema['id']] = metadataSchema;\n        }\n        for (var _b = 0, _c = data['metadata_items']; _b < _c.length; _b++) {\n            var metadataItem = _c[_b];\n            var key = metadataSchemas[metadataItem['metadata_schema_id']].key;\n            var kind = metadataSchemas[metadataItem['metadata_schema_id']].kind;\n            var value = metadataItem[\"value_\" + kind];\n            metadata[key] = value;\n        }\n        return new TrackInfo(name, metadata);\n    };\n    TrackInfo.prototype.getName = function () {\n        return this.__name;\n    };\n    TrackInfo.prototype.getMetadata = function () {\n        return this.__metadata;\n    };\n    return TrackInfo;\n}());\nexports.TrackInfo = TrackInfo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/channel/TrackInfo.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Factory_1 = require(\"./Factory\");\nvar Base_1 = require(\"../Base\");\nvar AudioManager = (function (_super) {\n    __extends(AudioManager, _super);\n    function AudioManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.__audioPlayers = {};\n        _this.__volume = 1.0;\n        return _this;\n    }\n    AudioManager.prototype.update = function (playlist, clock) {\n        var tracks = playlist.getTracks();\n        var existingIds = Object.keys(this.__audioPlayers);\n        var newIds = Object.keys(tracks);\n        var tracksToAdd = this.__diff(tracks, this.__audioPlayers);\n        var tracksToRemove = this.__diff(this.__audioPlayers, tracks);\n        for (var id in tracksToAdd) {\n            this.debug(\"Adding track: ID = \" + id);\n            this.__audioPlayers[id] = Factory_1.Factory.makeFromTrack(tracks[id], clock);\n            this.__audioPlayers[id].setVolume(this.__volume);\n            this.__audioPlayers[id].on('playback-started', this.__onAudioPlayerPlaybackStarted.bind(this));\n            this.__audioPlayers[id].on('position', this.__onAudioPlayerPosition.bind(this));\n            this.__audioPlayers[id].start();\n        }\n        for (var id in tracksToRemove) {\n            this.debug(\"Removing track: ID = \" + id);\n            this.__removeAudioPlayer(id);\n        }\n    };\n    AudioManager.prototype.cleanup = function () {\n        for (var id in this.__audioPlayers) {\n            this.__removeAudioPlayer(id);\n        }\n        return this;\n    };\n    AudioManager.prototype.setVolume = function (volume) {\n        if (volume < 0.0 || volume > 1.0) {\n            throw new Error('Volume out of range');\n        }\n        this.__volume = volume;\n        for (var id in this.__audioPlayers) {\n            this.__audioPlayers[id].setVolume(volume);\n        }\n        return this;\n    };\n    AudioManager.prototype._loggerTag = function () {\n        return \"\" + this['constructor']['name'];\n    };\n    AudioManager.prototype.__removeAudioPlayer = function (id) {\n        if (this.__currentTrack === this.__audioPlayers[id].getTrack()) {\n            this.__currentTrack = undefined;\n        }\n        this.__audioPlayers[id].offAll();\n        this.__audioPlayers[id].stop();\n        delete this.__audioPlayers[id];\n    };\n    AudioManager.prototype.__diff = function (object1, object2) {\n        var result = {};\n        var array1 = Object.keys(object1);\n        var array2 = Object.keys(object2);\n        for (var _i = 0, array1_1 = array1; _i < array1_1.length; _i++) {\n            var item = array1_1[_i];\n            if (array2.indexOf(item) === -1) {\n                result[item] = object1[item];\n            }\n        }\n        return result;\n    };\n    AudioManager.prototype.__onAudioPlayerPlaybackStarted = function (audioPlayer) {\n        this.__currentTrack = audioPlayer.getTrack();\n        this._trigger('playback-started', this.__currentTrack);\n        for (var id in this.__audioPlayers) {\n            var iteratedAudioPlayer = this.__audioPlayers[id];\n            var iteratedTrack = iteratedAudioPlayer.getTrack();\n            if (iteratedAudioPlayer !== audioPlayer && iteratedTrack.getCueInAt() <= this.__currentTrack.getCueInAt()) {\n                this.debug(\"Applying fade out to player for track \" + iteratedAudioPlayer.getTrack().getId() + \" so it does not overlap with player for track \" + audioPlayer.getTrack().getId());\n                iteratedAudioPlayer.fadeOut(1000);\n            }\n        }\n    };\n    AudioManager.prototype.__onAudioPlayerPosition = function (audioPlayer, position, duration) {\n        var track = audioPlayer.getTrack();\n        if (track === this.__currentTrack) {\n            this._trigger('position', track, position, duration);\n        }\n    };\n    return AudioManager;\n}(Base_1.Base));\nexports.AudioManager = AudioManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/audio/AudioManager.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HTMLPlayer_1 = require(\"./HTMLPlayer\");\nvar Factory = (function () {\n    function Factory() {\n    }\n    Factory.makeFromTrack = function (track, clock) {\n        return new HTMLPlayer_1.HTMLPlayer(track, clock);\n    };\n    return Factory;\n}());\nexports.Factory = Factory;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/audio/Factory.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base_1 = require(\"../Base\");\nvar FADE_OUT_INTERVAL = 25;\nvar HTMLPlayer = (function (_super) {\n    __extends(HTMLPlayer, _super);\n    function HTMLPlayer(track, clock) {\n        var _this = _super.call(this) || this;\n        _this.__started = false;\n        _this.__cueInTimeoutId = 0;\n        _this.__restartTimeoutId = 0;\n        _this.__positionIntervalId = 0;\n        _this.__volume = 1.0;\n        _this.__fadeVolumeMultiplier = 1.0;\n        _this.__fadeIntervalId = 0;\n        _this.__track = track;\n        _this.__clock = clock;\n        return _this;\n    }\n    HTMLPlayer.prototype.start = function () {\n        if (!this.__started) {\n            this.debug('Starting');\n            this.__started = true;\n            this.__preparePlayback();\n        }\n        else {\n            throw new Error('Attempt to start HTML Player that is already started');\n        }\n        return this;\n    };\n    HTMLPlayer.prototype.stop = function () {\n        if (this.__started) {\n            this.debug('Stopping');\n            this.__stopPlayback();\n            this.__started = false;\n        }\n        else {\n            throw new Error('Attempt to stop HTML Player that is not started');\n        }\n        return this;\n    };\n    HTMLPlayer.prototype.setVolume = function (volume) {\n        if (volume < 0.0 || volume > 1.0) {\n            throw new Error('Volume out of range');\n        }\n        this.__volume = volume;\n        if (this.__audio) {\n            this.__audio.volume = volume * this.__fadeVolumeMultiplier;\n        }\n        return this;\n    };\n    HTMLPlayer.prototype.getTrack = function () {\n        return this.__track;\n    };\n    HTMLPlayer.prototype.fadeOut = function (duration) {\n        var _this = this;\n        if (this.__fadeIntervalId === 0) {\n            this.debug(\"Starting fade out of duration \" + duration + \" ms\");\n            var step_1 = FADE_OUT_INTERVAL / duration;\n            this.__fadeIntervalId = setInterval(function () {\n                _this.__fadeVolumeMultiplier -= step_1;\n                if (_this.__fadeVolumeMultiplier <= 0) {\n                    _this.__fadeVolumeMultiplier = 0;\n                    clearInterval(_this.__fadeIntervalId);\n                    _this.__fadeIntervalId = 0;\n                    _this.debug(\"Finishing fade out\");\n                }\n                _this.debug(\"Fade out: \" + _this.__fadeVolumeMultiplier + \"%\");\n                if (_this.__audio) {\n                    _this.__audio.volume = _this.__volume * _this.__fadeVolumeMultiplier;\n                }\n            }, FADE_OUT_INTERVAL);\n        }\n        return this;\n    };\n    HTMLPlayer.prototype._loggerTag = function () {\n        return this['constructor']['name'] + \" \" + this.__track.getId();\n    };\n    HTMLPlayer.prototype.__onAudioCanPlayThroughWhenPreparing = function (e) {\n        this.debug('Can play through (when preparing)');\n        var now = this.__clock.nowAsTimestamp();\n        var cueInAt = this.__track.getCueInAt().valueOf();\n        var cueOutAt = this.__track.getCueOutAt().valueOf();\n        if (now >= cueOutAt) {\n            this.warn('Unable to play: Track is obsolete');\n        }\n        else {\n            if (now < cueInAt) {\n                var timeout = cueInAt - now;\n                this.debug(\"Waiting for \" + timeout + \" ms\");\n                this.__cueInTimeoutId = setTimeout(this.__onCueInTimeout.bind(this), timeout);\n            }\n            else if (now > cueInAt) {\n                this.__audio.oncanplaythrough = this.__onAudioCanPlayThroughWhenReady.bind(this);\n                var position = now - cueInAt;\n                this.debug(\"Seeking to \" + position + \" ms\");\n                this.__audio.currentTime = position / 1000.0;\n            }\n            else {\n                this.__startPlayback();\n            }\n        }\n    };\n    HTMLPlayer.prototype.__onAudioCanPlayThroughWhenReady = function (e) {\n        this.debug('Can play through (when ready)');\n        this.__startPlayback();\n    };\n    HTMLPlayer.prototype.__onAudioError = function (e) {\n        this.warn('Error');\n        this.__stopPlayback();\n        this.__scheduleRestart();\n    };\n    HTMLPlayer.prototype.__onAudioEnded = function (e) {\n        this.debug('EOS');\n        this.__stopPlayback();\n    };\n    HTMLPlayer.prototype.__onAudioSeeking = function (e) {\n        this.debug('Seeking');\n    };\n    HTMLPlayer.prototype.__onAudioSeeked = function (e) {\n        this.debug('Seeked');\n    };\n    HTMLPlayer.prototype.__onAudioWaiting = function (e) {\n        this.warn('Waiting');\n    };\n    HTMLPlayer.prototype.__onAudioStalled = function (e) {\n        this.warn('Stalled');\n    };\n    HTMLPlayer.prototype.__onAudioSuspended = function (e) {\n        this.warn('Suspended');\n    };\n    HTMLPlayer.prototype.__onCueInTimeout = function () {\n        this.debug('Cue In timeout has passed');\n        this.__cueInTimeoutId = 0;\n        this.__startPlayback();\n    };\n    HTMLPlayer.prototype.__preparePlayback = function () {\n        this.debug('Preparing playback');\n        this.__fadeVolumeMultiplier = 1.0;\n        this.__audio = new Audio();\n        this.__audio.volume = this.__volume;\n        this.__audio.preload = 'none';\n        this.__audio.src = this.__track.getFileUrl();\n        var now = this.__clock.nowAsTimestamp();\n        var cueInAt = this.__track.getCueInAt().valueOf();\n        var cueOutAt = this.__track.getCueOutAt().valueOf();\n        if (now >= cueOutAt) {\n            this.warn('Unable to set initial currentTime: Track is obsolete');\n        }\n        else {\n            if (now <= cueInAt) {\n                this.__audio.currentTime = 0;\n            }\n            else {\n                var position = now - cueInAt;\n                this.debug(\"Setting initial currentTime to \" + position + \" ms\");\n                this.__audio.onseeking = this.__onAudioSeeking.bind(this);\n                this.__audio.onseeked = this.__onAudioSeeked.bind(this);\n                this.__audio.currentTime = position / 1000.0;\n            }\n        }\n        this.__audio.oncanplaythrough = this.__onAudioCanPlayThroughWhenPreparing.bind(this);\n        this.__audio.onerror = this.__onAudioError.bind(this);\n        this.__audio.load();\n    };\n    HTMLPlayer.prototype.__startPlayback = function () {\n        this.debug('Starting playback');\n        this.__positionIntervalId = setInterval(this.__onPositionInterval.bind(this), 250);\n        this.__audio.onwaiting = this.__onAudioWaiting.bind(this);\n        this.__audio.onstalled = this.__onAudioStalled.bind(this);\n        this.__audio.onsuspend = this.__onAudioSuspended.bind(this);\n        this.__audio.onended = this.__onAudioEnded.bind(this);\n        this.__audio.play();\n        this._trigger('playback-started', this);\n    };\n    HTMLPlayer.prototype.__stopPlayback = function () {\n        this.debug('Stopping playback');\n        if (this.__audio) {\n            this.__audio.oncanplaythrough = undefined;\n            this.__audio.onerror = undefined;\n            this.__audio.onended = undefined;\n            this.__audio.onwaiting = undefined;\n            this.__audio.onstalled = undefined;\n            this.__audio.onsuspend = undefined;\n            this.__audio.onseeking = undefined;\n            this.__audio.onseeked = undefined;\n            if (this.__audio.readyState == 4) {\n                this.__audio.pause();\n            }\n            this.__audio.src = '';\n            delete this.__audio;\n            this.__audio = undefined;\n        }\n        if (this.__fadeIntervalId !== 0) {\n            clearInterval(this.__fadeIntervalId);\n            this.__fadeIntervalId = 0;\n        }\n        if (this.__cueInTimeoutId !== 0) {\n            clearTimeout(this.__cueInTimeoutId);\n            this.__cueInTimeoutId = 0;\n        }\n        if (this.__restartTimeoutId !== 0) {\n            clearTimeout(this.__restartTimeoutId);\n            this.__restartTimeoutId = 0;\n        }\n        if (this.__positionIntervalId !== 0) {\n            clearInterval(this.__positionIntervalId);\n            this.__positionIntervalId = 0;\n        }\n    };\n    HTMLPlayer.prototype.__scheduleRestart = function () {\n        var _this = this;\n        if (this.__started) {\n            var timeout = 500 + Math.round(Math.random() * 250);\n            this.debug(\"Scheduling restart in \" + timeout + \" ms\");\n            this.__restartTimeoutId = setTimeout(function () {\n                _this.__restartTimeoutId = 0;\n                _this.__preparePlayback();\n            }, timeout);\n        }\n    };\n    HTMLPlayer.prototype.__onPositionInterval = function () {\n        if (this.__audio) {\n            var position = Math.round(this.__audio.currentTime * 1000);\n            var cueInAt = this.__track.getCueInAt().valueOf();\n            var cueOutAt = this.__track.getCueOutAt().valueOf();\n            var duration = cueOutAt - cueInAt;\n            this._trigger('position', this, position, duration);\n        }\n    };\n    return HTMLPlayer;\n}(Base_1.Base));\nexports.HTMLPlayer = HTMLPlayer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/audio/HTMLPlayer.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Base_1 = require(\"../Base\");\nvar phoenix_1 = require(\"phoenix\");\nvar StreamManager = (function (_super) {\n    __extends(StreamManager, _super);\n    function StreamManager(channelId) {\n        var _this = _super.call(this) || this;\n        _this.__volume = 1.0;\n        _this.__started = false;\n        _this.__restartTimeoutId = 0;\n        _this.__channelId = channelId;\n        _this.__socket = new phoenix_1.Socket(\"wss://agenda.radiokitapp.org/api/stream/v1.0\");\n        return _this;\n    }\n    StreamManager.prototype.start = function () {\n        if (!this.__started) {\n            this.debug('Starting');\n            this.__started = true;\n            this.__startPlayback();\n            this.__subscribeMetadata();\n        }\n        else {\n            throw new Error('Attempt to start Stream Manager that is already started');\n        }\n        return this;\n    };\n    StreamManager.prototype.stop = function () {\n        if (this.__started) {\n            this.debug('Stopping');\n            this.__stopPlayback();\n            this.__unsubscribeMetadata();\n            this.__started = false;\n        }\n        else {\n            throw new Error('Attempt to stop Stream Manager that is not started');\n        }\n        return this;\n    };\n    StreamManager.prototype.setVolume = function (volume) {\n        if (volume < 0.0 || volume > 1.0) {\n            throw new Error('Volume out of range');\n        }\n        this.__volume = volume;\n        if (this.__audio) {\n            this.__audio.volume = volume;\n        }\n        return this;\n    };\n    StreamManager.prototype._loggerTag = function () {\n        return \"\" + this['constructor']['name'];\n    };\n    StreamManager.prototype.__onAudioError = function (e) {\n        this.warn('Error');\n        this.__stopPlayback();\n        this.__scheduleRestart();\n    };\n    StreamManager.prototype.__onAudioEnded = function (e) {\n        this.debug('EOS');\n        this.__stopPlayback();\n        this.__scheduleRestart();\n    };\n    StreamManager.prototype.__onAudioWaiting = function (e) {\n        this.warn('Waiting');\n    };\n    StreamManager.prototype.__onAudioStalled = function (e) {\n        this.warn('Stalled');\n    };\n    StreamManager.prototype.__onAudioSuspended = function (e) {\n        this.warn('Suspended');\n    };\n    StreamManager.prototype.__subscribeMetadata = function () {\n        var _this = this;\n        this.__socket.connect();\n        this.__channel = this.__socket.channel(\"broadcast:metadata:\" + this.__channelId);\n        this.__channel.on(\"update\", function (payload) {\n            _this.debug(\"Received metadata: payload = \" + JSON.stringify(payload));\n            _this._trigger(\"channel-metadata-update\", payload);\n        });\n        this.__channel.join()\n            .receive(\"ok\", function (_a) {\n            var messages = _a.messages;\n            return _this.debug(\"Subscribed to metadata\");\n        })\n            .receive(\"error\", function (_a) {\n            var reason = _a.reason;\n            return _this.warn(\"Failed to subscribe to metadata: error = \" + reason);\n        })\n            .receive(\"timeout\", function () { return _this.warn(\"Failed to subscribe to metadata: timeout\"); });\n    };\n    StreamManager.prototype.__unsubscribeMetadata = function () {\n        this.__channel.leave();\n        this.__socket.disconnect();\n    };\n    StreamManager.prototype.__startPlayback = function () {\n        this.debug('Starting playback');\n        this.__audio = new Audio();\n        this.__audio.volume = this.__volume;\n        this.__audio.src = \"http://cluster.radiokitstream.org/\" + this.__channelId + \".mp3\";\n        this.__audio.onerror = this.__onAudioError.bind(this);\n        this.__audio.onended = this.__onAudioEnded.bind(this);\n        this.__audio.onwaiting = this.__onAudioWaiting.bind(this);\n        this.__audio.onstalled = this.__onAudioStalled.bind(this);\n        this.__audio.onsuspend = this.__onAudioSuspended.bind(this);\n        this.__audio.play();\n        this._trigger('playback-started');\n    };\n    StreamManager.prototype.__stopPlayback = function () {\n        this.debug('Stopping playback');\n        if (this.__audio) {\n            this.__audio.onerror = undefined;\n            this.__audio.onended = undefined;\n            this.__audio.onwaiting = undefined;\n            this.__audio.onstalled = undefined;\n            this.__audio.onsuspend = undefined;\n            if (this.__audio.readyState == 4) {\n                this.__audio.pause();\n            }\n            this.__audio.src = '';\n            delete this.__audio;\n            this.__audio = undefined;\n        }\n        if (this.__restartTimeoutId !== 0) {\n            clearTimeout(this.__restartTimeoutId);\n            this.__restartTimeoutId = 0;\n        }\n    };\n    StreamManager.prototype.__scheduleRestart = function () {\n        var _this = this;\n        if (this.__started) {\n            var timeout = 500 + Math.round(Math.random() * 250);\n            this.debug(\"Scheduling restart in \" + timeout + \" ms\");\n            this.__restartTimeoutId = setTimeout(function () {\n                _this.__restartTimeoutId = 0;\n                _this.__startPlayback();\n            }, timeout);\n        }\n    };\n    return StreamManager;\n}(Base_1.Base));\nexports.StreamManager = StreamManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/audio/StreamManager.ts\n// module id = 12\n// module chunks = 0","(function(exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are multiplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket(\"/ws\", {params: {userToken: \"123\"}})\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket,\n// the authentication params, as well as options that can be found in\n// the Socket docs, such as configuring the `LongPoll` transport, and\n// heartbeat.\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here's an example chat room example where `\"new_msg\"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error/timeout matches:\n//\n//     let channel = socket.channel(\"room:123\", {token: roomToken})\n//     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n//     $input.onEnter( e => {\n//       channel.push(\"new_msg\", {body: e.target.val}, 10000)\n//        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n//        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n//        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n//     })\n//     channel.join()\n//       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n//       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n//       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\n//\n//\n// ## Joining\n//\n// Creating a channel with `socket.channel(topic, params)`, binds the params to\n// `channel.params`, which are sent up on `channel.join()`.\n// Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an \"ok\" status, while unsuccessful joins\n// receive \"error\".\n//\n// ## Duplicate Join Subscriptions\n//\n// While the client may join any number of topics on any number of channels,\n// the client may only hold a single subscription for each unique topic at any\n// given time. When attempting to create a duplicate subscription,\n// the server will close the existing channel, log a warning, and\n// spawn a new channel for the topic. The client will have their\n// `channel.onClose` callbacks fired for the existing channel, and the new\n// channel join will have its receive hooks processed as normal.\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `channel.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n//  and take action after some period of waiting. The default timeout is 5000ms.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\n//     socket.onClose( () => console.log(\"the connection dropped\") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     channel.onError( () => console.log(\"there was an error!\") )\n//     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attempted\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `channel.leave()`\n//\n//\n// ## Presence\n//\n// The `Presence` object provides features for syncing presence information\n// from the server with the client and handling presences joining and leaving.\n//\n// ### Syncing initial state from the server\n//\n// `Presence.syncState` is used to sync the list of presences on the server\n// with the client's state. An optional `onJoin` and `onLeave` callback can\n// be provided to react to changes in the client's local presences across\n// disconnects and reconnects with the server.\n//\n// `Presence.syncDiff` is used to sync a diff of presence join and leave\n// events from the server, as they happen. Like `syncState`, `syncDiff`\n// accepts optional `onJoin` and `onLeave` callbacks to react to a user\n// joining or leaving from a device.\n//\n// ### Listing Presences\n//\n// `Presence.list` is used to return a list of presence information\n// based on the local state of metadata. By default, all presence\n// metadata is returned, but a `listBy` function can be supplied to\n// allow the client to select which metadata to use for a given presence.\n// For example, you may have a user online from different devices with a\n// a metadata status of \"online\", but they have set themselves to \"away\"\n// on another device. In this case, they app may choose to use the \"away\"\n// status for what appears on the UI. The example below defines a `listBy`\n// function which prioritizes the first metadata which was registered for\n// each user. This could be the first tab they opened, or the first device\n// they came online from:\n//\n//     let state = {}\n//     state = Presence.syncState(state, stateFromServer)\n//     let listBy = (id, {metas: [first, ...rest]}) => {\n//       first.count = rest.length + 1 // count of this user's presences\n//       first.id = id\n//       return first\n//     }\n//     let onlineUsers = Presence.list(state, listBy)\n//\n//\n// ### Example Usage\n//\n//     // detect if user has joined for the 1st time or from another tab/device\n//     let onJoin = (id, current, newPres) => {\n//       if(!current){\n//         console.log(\"user has entered for the first time\", newPres)\n//       } else {\n//         console.log(\"user additional presence\", newPres)\n//       }\n//     }\n//     // detect if user has left from all tabs/devices, or is still present\n//     let onLeave = (id, current, leftPres) => {\n//       if(current.metas.length === 0){\n//         console.log(\"user has left from all devices\", leftPres)\n//       } else {\n//         console.log(\"user left from a device\", leftPres)\n//       }\n//     }\n//     let presences = {} // client's initial empty presence state\n//     // receive initial presence data from server, sent after join\n//     myChannel.on(\"presence_state\", state => {\n//       presences = Presence.syncState(presences, state, onJoin, onLeave)\n//       displayUsers(Presence.list(presences))\n//     })\n//     // receive \"presence_diff\" from server, containing join/leave events\n//     myChannel.on(\"presence_diff\", diff => {\n//       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\n//       this.setState({users: Presence.list(room.presences, listBy)})\n//     })\n//\nvar VSN = \"1.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 10000;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\n\nvar Push = function () {\n\n  // Initializes the Push\n  //\n  // channel - The Channel\n  // event - The event, for example `\"phx_join\"`\n  // payload - The payload, for example `{user_id: 123}`\n  // timeout - The push timeout in milliseconds\n  //\n\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref\n      });\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({ status: status, callback: callback });\n      return this;\n    }\n\n    // private\n\n  }, {\n    key: \"matchReceive\",\n    value: function matchReceive(_ref) {\n      var status = _ref.status;\n      var response = _ref.response;\n      var ref = _ref.ref;\n\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"cancelRefEvent\",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel.off(this.refEvent);\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n        _this.cancelTimeout();\n        _this.receivedResp = payload;\n        _this.matchReceive(payload);\n      });\n\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"hasReceived\",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, { status: status, response: response });\n    }\n  }]);\n\n  return Push;\n}();\n\nvar Channel = exports.Channel = function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this2.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this2.state = CHANNEL_STATES.joined;\n      _this2.rejoinTimer.reset();\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this2.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this2.rejoinTimer.reset();\n      _this2.socket.log(\"channel\", \"close \" + _this2.topic + \" \" + _this2.joinRef());\n      _this2.state = CHANNEL_STATES.closed;\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      if (_this2.isLeaving() || _this2.isClosed()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"error \" + _this2.topic, reason);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (!_this2.isJoining()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"timeout \" + _this2.topic, _this2.joinPush.timeout);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      if (this.joinedOnce) {\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({ event: event, callback: callback });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.timeout : arguments[2];\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use channel.join() before pushing events\";\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    // Leaves the channel\n    //\n    // Unsubscribes from server events, and\n    // instructs channel to terminate on server\n    //\n    // Triggers onClose() hooks\n    //\n    // To receive leave acknowledgements, use the a `receive`\n    // hook to bind to the server ack, ie:\n    //\n    //     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n    //\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this3.socket.log(\"channel\", \"leave \" + _this3.topic);\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\", _this3.joinRef());\n      };\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    // Overridable message hook\n    //\n    // Receives all events for specialized message handling\n    // before dispatching to the channel callbacks.\n    //\n    // Must return the payload, modified or unmodified\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n\n    // private\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n      if (this.isLeaving()) {\n        return;\n      }\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close;\n      var error = CHANNEL_EVENTS.error;\n      var leave = CHANNEL_EVENTS.leave;\n      var join = CHANNEL_EVENTS.join;\n\n      if (ref && [close, error, leave, join].indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n      var handledPayload = this.onMessage(event, payload, ref);\n      if (payload && !handledPayload) {\n        throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n      }\n\n      this.bindings.filter(function (bind) {\n        return bind.event === event;\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\" + ref;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n\nvar Socket = exports.Socket = function () {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\n  //                                               \"wss://example.com\"\n  //                                               \"/ws\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n  //               Defaults to WebSocket with automatic LongPoll fallback.\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n\n  function Socket(endPoint) {\n    var _this4 = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || window.WebSocket || LongPoll;\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = endPoint + \"/\" + TRANSPORTS.websocket;\n    this.reconnectTimer = new Timer(function () {\n      _this4.disconnect(function () {\n        return _this4.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: \"protocol\",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n      if (uri.charAt(1) === \"/\") {\n        return this.protocol() + \":\" + uri;\n      }\n\n      return this.protocol() + \"://\" + location.host + uri;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n      }\n      callback && callback();\n    }\n\n    // params - The params to send when connecting, for example `{user_id: userToken}`\n\n  }, {\n    key: \"connect\",\n    value: function connect(params) {\n      var _this5 = this;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = params;\n      }\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n      this.conn.onopen = function () {\n        return _this5.onConnOpen();\n      };\n      this.conn.onerror = function (error) {\n        return _this5.onConnError(error);\n      };\n      this.conn.onmessage = function (event) {\n        return _this5.onConnMessage(event);\n      };\n      this.conn.onclose = function (event) {\n        return _this5.onConnClose(event);\n      };\n    }\n\n    // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\n    //\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      var _this6 = this;\n\n      this.log(\"transport\", \"connected to \" + this.endPointURL());\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this6.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n        case SOCKET_STATES.open:\n          return \"open\";\n        case SOCKET_STATES.closing:\n          return \"closing\";\n        default:\n          return \"closed\";\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this7 = this;\n\n      var topic = data.topic;\n      var event = data.event;\n      var payload = data.payload;\n      var ref = data.ref;\n\n      var callback = function callback() {\n        return _this7.conn.send(JSON.stringify(data));\n      };\n      this.log(\"push\", topic + \" \" + event + \" (\" + ref + \")\", payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n\n    // Return the next message ref, accounting for overflows\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n      this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef() });\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var msg = JSON.parse(rawMessage.data);\n      var topic = msg.topic;\n      var event = msg.event;\n      var payload = msg.payload;\n      var ref = msg.ref;\n\n      this.log(\"receive\", (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\n      this.channels.filter(function (channel) {\n        return channel.isMember(topic);\n      }).forEach(function (channel) {\n        return channel.trigger(event, payload, ref);\n      });\n      this.stateChangeCallbacks.message.forEach(function (callback) {\n        return callback(msg);\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nvar LongPoll = exports.LongPoll = function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: \"normalizeEndpoint\",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: \"endpointURL\",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n    }\n  }, {\n    key: \"closeAndRetry\",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: \"ontimeout\",\n    value: function ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this8 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status;\n          var token = resp.token;\n          var messages = resp.messages;\n\n          _this8.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              return _this8.onmessage({ data: JSON.stringify(msg) });\n            });\n            _this8.poll();\n            break;\n          case 204:\n            _this8.poll();\n            break;\n          case 410:\n            _this8.readyState = SOCKET_STATES.open;\n            _this8.onopen();\n            _this8.poll();\n            break;\n          case 0:\n          case 500:\n            _this8.onerror();\n            _this8.closeAndRetry();\n            break;\n          default:\n            throw \"unhandled poll status \" + status;\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this9 = this;\n\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this9.onerror(status);\n          _this9.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\n\nvar Ajax = exports.Ajax = function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: \"request\",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (window.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var req = window.XMLHttpRequest ? new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n        new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: \"xdomainRequest\",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this10 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n      req.onload = function () {\n        var response = _this10.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      // Work around bug in IE9 that requires an attached onprogress handler\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: \"xhrRequest\",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this11 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint, true);\n      req.setRequestHeader(\"Content-Type\", accept);\n      req.onerror = function () {\n        callback && callback(null);\n      };\n      req.onreadystatechange = function () {\n        if (req.readyState === _this11.states.complete && callback) {\n          var response = _this11.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(resp) {\n      return resp && resp !== \"\" ? JSON.parse(resp) : null;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n        var paramKey = parentKey ? parentKey + \"[\" + key + \"]\" : key;\n        var paramVal = obj[key];\n        if ((typeof paramVal === \"undefined\" ? \"undefined\" : _typeof(paramVal)) === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n      return queryStr.join(\"&\");\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\" + url + prefix + this.serialize(params);\n    }\n  }]);\n\n  return Ajax;\n}();\n\nAjax.states = { complete: 4 };\n\nvar Presence = exports.Presence = {\n  syncState: function syncState(currentState, newState, onJoin, onLeave) {\n    var _this12 = this;\n\n    var state = this.clone(currentState);\n    var joins = {};\n    var leaves = {};\n\n    this.map(state, function (key, presence) {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, function (key, newPresence) {\n      var currentPresence = state[key];\n      if (currentPresence) {\n        (function () {\n          var newRefs = newPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var curRefs = currentPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var joinedMetas = newPresence.metas.filter(function (m) {\n            return curRefs.indexOf(m.phx_ref) < 0;\n          });\n          var leftMetas = currentPresence.metas.filter(function (m) {\n            return newRefs.indexOf(m.phx_ref) < 0;\n          });\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n          if (leftMetas.length > 0) {\n            leaves[key] = _this12.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        })();\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave);\n  },\n  syncDiff: function syncDiff(currentState, _ref2, onJoin, onLeave) {\n    var joins = _ref2.joins;\n    var leaves = _ref2.leaves;\n\n    var state = this.clone(currentState);\n    if (!onJoin) {\n      onJoin = function onJoin() {};\n    }\n    if (!onLeave) {\n      onLeave = function onLeave() {};\n    }\n\n    this.map(joins, function (key, newPresence) {\n      var currentPresence = state[key];\n      state[key] = newPresence;\n      if (currentPresence) {\n        var _state$key$metas;\n\n        (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(currentPresence.metas));\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, function (key, leftPresence) {\n      var currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      var refsToRemove = leftPresence.metas.map(function (m) {\n        return m.phx_ref;\n      });\n      currentPresence.metas = currentPresence.metas.filter(function (p) {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  },\n  list: function list(presences, chooser) {\n    if (!chooser) {\n      chooser = function chooser(key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, function (key, presence) {\n      return chooser(key, presence);\n    });\n  },\n\n  // private\n\n  map: function map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(function (key) {\n      return func(key, obj[key]);\n    });\n  },\n  clone: function clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//    reconnectTimer.scheduleTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//\n\nvar Timer = function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    // Cancels any previous scheduleTimeout and schedules callback\n\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var _this13 = this;\n\n      clearTimeout(this.timer);\n\n      this.timer = setTimeout(function () {\n        _this13.tries = _this13.tries + 1;\n        _this13.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n})(typeof(exports) === \"undefined\" ? window.Phoenix = window.Phoenix || {} : exports);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/phoenix/priv/static/phoenix.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}